// Code generation was used by GitHub Copilot to assist in creating this file.
// Only inline generation was used for repetative sections and to speed up development
// Server logs were generated by GitHub Copilot using Claude Sonnet 4.5

import Postgres from "./postgres";
import config from "./config.yml";
import type {
  Game,
  GameExchange,
  GamePartial,
  LoginUser,
  User,
  UserPartial,
} from "./types";
import Auth from "./auth";
import Validation from "./validation";
import Responses from "./responses";

const server = config.server;

if (Bun.argv.includes("--drop-schema")) await Postgres.dropSchema();
await Postgres.createSchema();

console.info(`Server listening on http://${server.domainName}:${server.port}`);
Bun.serve({
  port: server.port,
  routes: {
    "/user": {
      PUT: async (request) => {
        let body: LoginUser;
        try {
          body = (await request.json()) as LoginUser;
        } catch (e) {
          return Responses.requestBodyParse();
        }

        const invalidField = Validation.validateLogin(
          body.email,
          body.password,
        );
        if (invalidField)
          return Responses.invalidField(invalidField.key, invalidField.value);

        let newToken: string | null = null;

        try {
          newToken = await Auth.loginUser(body.email, body.password);
        } catch (e) {
          console.error(`Error logging in user ${body.email}:`, e);
          return Responses.internalServerError(
            "Error occurred while logging in the user",
          );
        }

        if (newToken === null) return Responses.incorrectLogin();

        console.info(`User logged in successfully: ${body.email}`);
        return Responses.loggedIn(newToken);
      },
      POST: async (request) => {
        let body: User;
        try {
          body = (await request.json()) as User;
        } catch (e) {
          return Responses.requestBodyParse();
        }

        const invalidField = Validation.validateUser(body);
        if (invalidField)
          return Responses.invalidField(invalidField.key, invalidField.value);

        const exists = await Postgres.userExists(body.email);
        if (exists) return Responses.userAlreadyExists();

        try {
          const token = await Auth.registerUser(body);
          console.info(`User registered successfully: ${body.email}`);
          return Responses.createdUser(token);
        } catch (e) {
          console.error(`Error registering user ${body.email}:`, e);
          return Responses.internalServerError(
            "Error occurred while logging in the user",
          );
        }
      },
      PATCH: async (request) => {
        let body: UserPartial;
        try {
          body = (await request.json()) as UserPartial;
        } catch (e) {
          return Responses.requestBodyParse();
        }

        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) return Responses.missingBearerToken();

        const userID = await Postgres.getUserIDFromToken(bearerToken);
        if (userID === 0) return Responses.tokenNotFound();

        if (Object.keys(body).length === 0) return Responses.emptyBody();

        const invalidField = Validation.validateUserDetails(body);
        if (invalidField)
          return Responses.invalidField(invalidField.key, invalidField.value);

        try {
          await Postgres.updateUserDetails(body, userID);
          console.info(`User details updated for userID ${userID}`);
          return Responses.userDetailsUpdated(body.name, body.streetAddress);
        } catch (e) {
          console.error(`Error updating user details for userID ${userID}:`, e);
          return Responses.internalServerError(
            "Error occurred while updating user details",
          );
        }
      },
    },
    "/game": {
      POST: async (request) => {
        let body: Game;
        try {
          body = (await request.json()) as Game;
        } catch (e) {
          return Responses.requestBodyParse();
        }

        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) return Responses.missingBearerToken();

        const userID = await Postgres.getUserIDFromToken(bearerToken);
        if (userID === 0) return Responses.tokenNotFound();

        const invalidField = Validation.validateGame(body);
        if (invalidField)
          return Responses.invalidField(invalidField.key, invalidField.value);

        try {
          await Postgres.addGame(body, userID);
          console.info(`Game created by userID ${userID}: ${body.name}`);
          return Response.json(body, { status: 201 });
        } catch (e) {
          console.error(`Error adding game for userID ${userID}:`, e);
          return Responses.internalServerError(
            "Error occurred while adding a game",
          );
        }
      },
    },
    "/game/:id": {
      GET: async (request) => {
        const gameID = Number(request.params.id);
        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) {
          console.info("Request missing bearer token");
          return Responses.missingBearerToken();
        }

        let game: Game | null = null;
        try {
          game = await Postgres.getGameByID(gameID);
        } catch (e) {
          console.error(`Error retrieving game ${gameID}:`, e);
          return Responses.internalServerError("An unexpected error occurred");
        }

        if (!game) return Responses.notFoundError(gameID);

        console.info(`Game retrieved: ${gameID}`);
        return Responses.foundGame(game);
      },
      PUT: async (request) => {
        const gameID = Number(request.params.id);
        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) {
          console.info("Request missing bearer token");
          return Responses.missingBearerToken();
        }

        const game = await Postgres.getGameByID(gameID);
        if (!game) return Responses.notFoundError(gameID);

        const userID = await Postgres.getUserIDFromToken(bearerToken);
        const ownsGame = await Auth.userOwnsGame(userID, gameID);
        if (!ownsGame)
          return Responses.notAuthorized(
            "User is not authorized to modify this game",
          );

        let body: Game;
        try {
          body = (await request.json()) as Game;
        } catch (e) {
          return Responses.requestBodyParse();
        }

        const invalidField = Validation.validateGame(body);
        if (invalidField)
          return Responses.invalidField(invalidField.key, invalidField.value);

        try {
          await Postgres.updateGameByID(gameID, body);
          const updatedGame = await Postgres.getGameByID(gameID);
          console.info(`Game ${gameID} updated by userID ${userID}`);
          return Response.json(updatedGame, { status: 200 });
        } catch (e) {
          console.error(`Error updating game ${gameID}:`, e);
          return Responses.internalServerError(
            "Error occurred while updating a game",
          );
        }
      },
      PATCH: async (request) => {
        const gameID = Number(request.params.id);
        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) {
          console.info("Request missing bearer token");
          return Responses.missingBearerToken();
        }

        const game = await Postgres.getGameByID(gameID);
        if (!game) return Responses.notFoundError(gameID);

        const userID = await Postgres.getUserIDFromToken(bearerToken);
        const ownsGame = await Auth.userOwnsGame(userID, gameID);
        if (!ownsGame)
          return Responses.notAuthorized(
            "User is not authorized to modify this game",
          );

        let body: GamePartial;
        try {
          body = (await request.json()) as GamePartial;
        } catch (e) {
          return Responses.requestBodyParse();
        }

        if (Object.keys(body).length === 0) return Responses.emptyBody();

        try {
          await Postgres.patchGameByID(gameID, body);
          const updatedGame = await Postgres.getGameByID(gameID);
          console.info(`Game ${gameID} patched by userID ${userID}`);
          return Response.json(updatedGame, { status: 200 });
        } catch (e) {
          console.error(`Error patching game ${gameID}:`, e);
          return Responses.internalServerError(
            "Error occurred while patching a game",
          );
        }
      },
      DELETE: async (request) => {
        const gameID = Number(request.params.id);
        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) {
          console.info("Request missing bearer token");
          return Responses.missingBearerToken();
        }

        const game = await Postgres.getGameByID(gameID);
        if (!game) return Responses.notFoundError(gameID);

        const userID = await Postgres.getUserIDFromToken(bearerToken);
        const ownsGame = await Auth.userOwnsGame(userID, gameID);
        if (!ownsGame)
          return Responses.notAuthorized(
            "User is not authorized to modify this game",
          );

        try {
          await Postgres.deleteGameByID(gameID);
          console.info(`Game ${gameID} deleted by userID ${userID}`);
          return Responses.foundGame(game);
        } catch (e) {
          console.error(`Error deleting game ${gameID}:`, e);
          return Responses.internalServerError(
            "Error occurred while deleting a game",
          );
        }
      },
    },
    "/exchange/:id": {
      POST: async (request) => {
        let body: GameExchange;
        try {
          body = (await request.json()) as GameExchange;
        } catch (e) {
          return Responses.requestBodyParse();
        }

        const gameID = Number(request.params.id);
        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) {
          console.info("Request missing bearer token");
          return Responses.missingBearerToken();
        }

        const userID = await Postgres.getUserIDFromToken(bearerToken);
        const ownsGame = await Auth.userOwnsGame(userID, gameID);
        if (!ownsGame)
          return Responses.notAuthorized(
            "User is not authorized to modify this game",
          );

        try {
          await Postgres.createExchange(gameID, body.toUserID);
          console.info(
            `Exchange created for game ${gameID} to userID ${body.toUserID}`,
          );
          return Responses.createdGameExchange(gameID, body.toUserID);
        } catch (e) {
          console.error(`Error creating exchange for game ${gameID}:`, e);
          return Responses.internalServerError(
            "Error occurred while creating an exchange",
          );
        }
      },
      GET: async (request) => {
        const gameID = Number(request.params.id);
        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) {
          console.info("Request missing bearer token");
          return Responses.missingBearerToken();
        }

        const userID = await Postgres.getUserIDFromToken(bearerToken);
        const ownsGame = await Auth.userOwnsGame(userID, gameID);
        if (!ownsGame)
          return Responses.notAuthorized("User cannot view this exchange");

        let exchange: GameExchange | null = null;
        try {
          exchange = await Postgres.getExchangeByID(gameID);
        } catch (e) {
          console.error(`Error retrieving exchange for game ${gameID}:`, e);
          return Responses.internalServerError("An unexpected error occurred");
        }

        if (!exchange) return Responses.notFoundError(gameID);

        console.info(`Exchange retrieved for game ${gameID}`);
        return Response.json(exchange, { status: 200 });
      },
      DELETE: async (request) => {
        const gameID = Number(request.params.id);
        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) {
          console.info("Request missing bearer token");
          return Responses.missingBearerToken();
        }

        const userID = await Postgres.getUserIDFromToken(bearerToken);
        const ownsGame = await Auth.userOwnsGame(userID, gameID);
        if (!ownsGame)
          return Responses.notAuthorized("User cannot delete this exchange");

        const game = await Postgres.getGameByID(gameID);

        try {
          await Postgres.deleteExchangeByID(gameID);
          console.info(`Exchange deleted for game ${gameID}`);
          return Response.json(game, { status: 200 });
        } catch (e) {
          console.error(`Error deleting exchange for game ${gameID}:`, e);
          return Responses.internalServerError(
            "Error occurred while deleting an exchange",
          );
        }
      },
    },
    "/receive/:id": {
      GET: async (request) => {
        const gameID = Number(request.params.id);
        const bearerToken = await Auth.getBearerToken(request);
        if (!bearerToken) {
          console.info("Request missing bearer token");
          return Responses.missingBearerToken();
        }

        const userID = await Postgres.getUserIDFromToken(bearerToken);

        let exchange: GameExchange | null = null;
        try {
          exchange = await Postgres.getExchangeByID(gameID);
        } catch (e) {
          console.error(`Error retrieving exchange for game ${gameID}:`, e);
          return Responses.internalServerError("An unexpected error occurred");
        }

        if (!exchange) return Responses.notFoundError(gameID);
        if (exchange.toUserID !== userID)
          return Responses.notAuthorized("User cannot receive this game");

        const game = await Postgres.getGameByID(gameID);
        if (!game) return Responses.notFoundError(gameID);

        try {
          await Postgres.updateGameOwner(gameID, userID);
          await Postgres.deleteExchangeByID(gameID);
          console.info(`Game ${gameID} transferred to userID ${userID}`);
        } catch (e) {
          console.error(
            `Error receiving game ${gameID} for userID ${userID}:`,
            e,
          );
          return Responses.internalServerError(
            "Error occurred while receiving the game",
          );
        }

        return Response.json(game, { status: 200 });
      },
    },
  },
});
